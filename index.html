<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PNR 문자열 처리기 (리팩토링 완료)</title>
    <style>
        /* CSS 스타일 (이전과 동일) */
        body { font-family: sans-serif; line-height: 1.6; padding: 20px; max-width: 800px; margin: 0 auto; }
        h1, h2 { border-bottom: 1px solid #ccc; padding-bottom: 5px; }
        label { display: block; margin-bottom: 5px; font-weight: bold; }
        textarea { width: 98%; min-height: 200px; margin-bottom: 15px; padding: 10px; border: 1px solid #ccc; font-size: 1rem; resize: vertical; }
        button { padding: 10px 20px; font-size: 1rem; cursor: pointer; background-color: #007bff; color: white; border: none; border-radius: 4px; margin-bottom: 20px; margin-right: 10px; }
        button:hover { background-color: #0056b3; }
        button:disabled { background-color: #cccccc; cursor: not-allowed; }
        #outputTable { width: 100%; border-collapse: collapse; margin-top: 10px; border: 1px solid #ccc; }
        #outputTable th, #outputTable td { border: 1px solid #ddd; padding: 8px; text-align: left; vertical-align: top; }
        #outputTable th { background-color: #f2f2f2; font-weight: bold; cursor: default; }
        #outputTable th:first-child, #outputTable td:first-child { text-align: center; width: 40px; }
        #outputTable tbody tr:nth-child(even) { background-color: #f9f9f9; }
        #outputTable tbody td { cursor: cell; }
        #outputTable tbody td.selected-cell { background-color: #d0e0ff !important; }
        body.is-selecting, body.is-selecting * { -webkit-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none; }
        .instructions { background-color: #eef; padding: 10px; border-radius: 5px; margin-bottom: 15px; font-size: 0.9em; }
        .error-message { color: red; font-weight: bold; }
        .empty-message { color: grey; font-style: italic; cursor: default !important; -webkit-user-select: text; -moz-user-select: text; -ms-user-select: text; user-select: text; }
        .copy-feedback { margin-left: 10px; color: green; font-weight: bold; display: inline-block;}
    </style>
</head>
<body>
    <h1>PNR 문자열 처리기 (리팩토링 완료)</h1>
    <div class="instructions">
        <p>아래 입력란에 PNR 문자열을 붙여넣고 '처리하기' 버튼을 클릭하세요.<br>
        결과 표의 셀들을 마우스로 드래그하여 영역을 선택한 후, '선택 영역 복사' 버튼 또는 Ctrl+C로 복사할 수 있습니다.</p>
    </div>
    <label for="pnrInput">PNR 입력:</label>
    <textarea id="pnrInput" placeholder="여기에 PNR 문자열을 입력하세요..."></textarea>
    <button id="parseButton">처리하기</button>
    <button id="copySelectionButton" disabled>선택 영역 복사</button>
    <button id="copyAllButton" disabled>전체 결과 복사</button>
    <span id="copyFeedback" class="copy-feedback"></span>

    <h2>출력 결과</h2>
    <table id="outputTable">
        <thead>
            <tr> <th>번호</th> <th>영문 성</th> <th>영문 이름</th> <th>생년월일</th> <th>성별</th> </tr>
        </thead>
        <tbody id="outputTableBody">
            <tr> <td colspan="5" class="empty-message">(아직 처리되지 않았습니다)</td> </tr>
        </tbody>
    </table>

    <script>
        // --- 상수 정의 ---
        const MONTH_MAP = { JAN: '01', FEB: '02', MAR: '03', APR: '04', MAY: '05', JUN: '06', JUL: '07', AUG: '08', SEP: '09', OCT: '10', NOV: '11', DEC: '12' };
        const POTENTIAL_TITLES = ["MS", "MR", "MISS", "MSTR", "INF"];
        const ENTRY_REGEX = /(\d+\.(?:\d+\s)?|\s*I\/\d+\s)(.*?)(?=\s*\d+\.(?:\d+\s)?|\s*I\/\d+\s|$)/gs;
        const INFANT_REGEX = /\((INF[A-Z]+\/[A-Z\s]+?\s+[A-Z]+\/\d{2}[A-Z]{3}\d{2})\)/;
        const INFANT_DETAIL_REGEX = /INF([A-Z]+)\/([A-Z\s]+?)\s+([A-Z]+)\/(\d{2}[A-Z]{3}\d{2})/;
        const CHD_MARKER = "(CHD/";
        const AGE_CODE_REGEX = /(\*C\d+|\*I\d+)/;
        const DATE_FORMAT_REGEX = /^\d{2}[A-Z]{3}\d{2}$/;

        // --- 요소 참조 ---
        const pnrInput = document.getElementById('pnrInput');
        const parseButton = document.getElementById('parseButton');
        const outputTableBody = document.getElementById('outputTableBody');
        const copySelectionButton = document.getElementById('copySelectionButton');
        const copyAllButton = document.getElementById('copyAllButton');
        const copyFeedback = document.getElementById('copyFeedback');
        const outputTable = document.getElementById('outputTable');

        // --- 상태 변수 ---
        let currentResults = [];
        let isSelecting = false;
        let startCell = null;
        let selectionBounds = null;

        // --- 이벤트 리스너 ---
        parseButton.addEventListener('click', handleParse);
        copyAllButton.addEventListener('click', handleTableCopy);
        copySelectionButton.addEventListener('click', handleSelectionCopy);
        outputTableBody.addEventListener('mousedown', handleMouseDown);
        outputTable.addEventListener('mouseover', handleMouseOver);
        document.addEventListener('mouseup', handleMouseUp);
        document.addEventListener('copy', handleNativeCopy);

        // --- 메인 핸들러 ---
        function handleParse() {
            const rawPnr = pnrInput.value.trim().replace(/\u00A0/g, ' ');
            outputTableBody.innerHTML = ''; currentResults = [];
            copyAllButton.disabled = true; copySelectionButton.disabled = true;
            copyFeedback.textContent = ''; selectionBounds = null;

            const displayInitialMessage = (message) => { /* ... */ }; // 내용은 동일하므로 축약
            if (!rawPnr) { displayInitialMessage("(입력된 PNR 문자열이 없습니다.)"); return; }

            try {
                const passengerDataArray = parsePnrString(rawPnr);
                currentResults = passengerDataArray;

                if (!passengerDataArray || passengerDataArray.length === 0) {
                    displayInitialMessage("(처리할 승객 정보가 없습니다.)");
                } else {
                    passengerDataArray.forEach((passengerData, index) => { // 테이블 생성
                        const row = outputTableBody.insertRow();
                        const numCell = row.insertCell(0); numCell.textContent = index + 1;
                        if (Array.isArray(passengerData) && passengerData.length === 4) {
                            passengerData.forEach(fieldData => { const cell = row.insertCell(); cell.textContent = fieldData ?? ''; });
                        } else {
                             console.error(`[handleParse] 잘못된 데이터 형식 발견 at index ${index}:`, passengerData);
                             for(let k=0; k<4; k++) { row.insertCell(); }
                        }
                    });
                    copyAllButton.disabled = false;
                }
            } catch (error) { /* ... 오류 처리 ... */ }
         }

        // --- 파싱 관련 함수 ---
        function parsePnrString(pnrText) {
             const results = [];
             console.log("새로운 정규식으로 항목 매칭 시도...");
             const matches = pnrText.matchAll(ENTRY_REGEX);
             let entryIndex = 0;
             for (const match of matches) {
                 entryIndex++;
                 let passengerDataString = match[2].trim(); // 내용 부분만 추출
                 console.log(`\n[매치 ${entryIndex} 분석]: "${passengerDataString}"`);
                 if (!passengerDataString) { console.log(` -> 유효 데이터 없음.`); continue; }
                 processPassengerData(passengerDataString, results, entryIndex); // 수정됨: monthMap 제거
             }
             if (entryIndex === 0) { console.warn("정규식으로 유효한 PNR 항목을 찾지 못했습니다."); }
             console.log("--- 최종 파싱 결과 배열 (passengerDataArray) ---");
             console.log(JSON.stringify(results, null, 2));
             console.log("-------------------------------------------");
             return results;
        }

        // [리팩토링됨] 개별 승객 데이터 처리 (조율자 역할)
        function processPassengerData(data, results, entryIndex = '?') {
            let lastName = '', firstName = '', dob = '', gender = '', title = '';

            // 1. Infant 정보 파싱 및 분리
            const { remainingData, infantInfo } = parseInfant(data);
            if (infantInfo) {
                 console.log(`  [항목 ${entryIndex}] 동반 유아 정보 파싱됨:`, infantInfo);
            }

            // 2. 이름 부분 분리
            const nameParts = extractNameParts(remainingData); // Infant 제거된 데이터 사용
            if (!nameParts) { // '/'가 없는 경우 처리
                 lastName = remainingData.trim().split(/\s+/)[0] || remainingData;
                 console.warn(`  [항목 ${entryIndex}] '/' 분리 불가.`);
                 if (lastName) { results.push([lastName, '', '', '']); }
                 // Infant 정보는 별도로 아래에서 추가됨
            } else {
                 lastName = nameParts.lastName;
                 // 3. DOB 추출 및 Name/Title 부분 정제
                 const { cleanedPart, dob: extractedDob } = extractDobAndClean(nameParts.nameAndTitlePart);
                 dob = extractedDob; // DOB 설정
                 // 4. Title 및 최종 이름 추출
                 const titleAndName = extractTitleAndName(cleanedPart);
                 title = titleAndName.title;
                 // 5. 이름 최종 정제 (공백/하이픈 제거)
                 firstName = titleAndName.firstName.replace(/[-\s]/g, '');
            }

             // 6. 성별 결정
             gender = getGender(title);

             // 7. 결과 추가 (주 승객)
             const finalPassengerData = [lastName, firstName, dob, gender];
             console.log(`  [항목 ${entryIndex}] -> 결과 추가 시도:`, finalPassengerData);
             if (lastName || firstName) { results.push(finalPassengerData); }
             else { console.warn(`  [항목 ${entryIndex}] 유효하지 않은 데이터로 판단되어 결과에 추가하지 않음.`); }


             // 8. 결과 추가 (동반 유아)
             if (infantInfo) {
                 const finalInfantData = [infantInfo.lastName, infantInfo.firstName, infantInfo.dob, infantInfo.gender];
                 console.log(`  [항목 ${entryIndex}] -> 결과 추가 시도 (동반 유아):`, finalInfantData);
                 results.push(finalInfantData);
             }
              console.log(`  [항목 ${entryIndex}] processPassengerData 종료.`);
        }

        // [신규] Infant 정보 파싱 함수
        function parseInfant(data) {
            let infantInfo = null;
            let remainingData = data;
            const infantMatch = data.match(INFANT_REGEX);
            if (infantMatch) {
                const infantDataString = infantMatch[1];
                remainingData = data.replace(infantMatch[0], '').trim(); // 원본 data에서 INF 제거
                const infantParts = infantDataString.match(INFANT_DETAIL_REGEX);
                if (infantParts) {
                    infantInfo = {
                        lastName: infantParts[1],
                        firstName: infantParts[2].trim().replace(/[-\s]/g, ''),
                        dob: convertDate(infantParts[4]), // monthMap 제거
                        gender: getGender(infantParts[3])
                    };
                }
            }
            return { remainingData, infantInfo };
        }

        // [신규] '/' 기준 이름 분리 함수
        function extractNameParts(data) {
            const slashIndex = data.indexOf('/');
            if (slashIndex === -1) {
                return null; // 슬래시 없으면 null 반환
            }
            const lastName = data.substring(0, slashIndex).trim();
            const nameAndTitlePart = data.substring(slashIndex + 1).trim();
            return { lastName, nameAndTitlePart };
        }

        // [신규] DOB 추출 및 부가 정보 제거 함수
        function extractDobAndClean(nameAndTitlePart) {
            let dob = '';
            let cleanedPart = nameAndTitlePart.replace(/\s+/g, ' ').trim(); // 중간 정제 포함

            const chdStartIndex = cleanedPart.indexOf(CHD_MARKER);
            if (chdStartIndex !== -1) {
                const dateStartIndex = chdStartIndex + CHD_MARKER.length;
                const dateEndIndex = dateStartIndex + 7;
                if (cleanedPart.length >= dateEndIndex + 1 && cleanedPart.charAt(dateEndIndex) === ')') {
                    const dateString = cleanedPart.substring(dateStartIndex, dateEndIndex);
                    if (DATE_FORMAT_REGEX.test(dateString)) {
                        dob = convertDate(dateString); // monthMap 제거
                        cleanedPart = cleanedPart.substring(0, chdStartIndex).trim();
                    } else {
                        const closingParenIndex = cleanedPart.indexOf(')', chdStartIndex);
                        if (closingParenIndex > chdStartIndex) {
                            cleanedPart = (cleanedPart.substring(0, chdStartIndex) + cleanedPart.substring(closingParenIndex + 1)).trim();
                        }
                    }
                }
            } else {
                const ageCodeMatch = cleanedPart.match(AGE_CODE_REGEX);
                if (ageCodeMatch) {
                    cleanedPart = cleanedPart.replace(ageCodeRegex, '').trim();
                }
            }
            return { cleanedPart, dob };
        }

        // [신규] Title 및 최종 이름 추출 함수
        function extractTitleAndName(cleanedPart) {
            let firstName = cleanedPart; // 기본값은 전체
            let title = '';
            for (const t of POTENTIAL_TITLES) {
                const regex = new RegExp(`\\s(${t})$`, 'i');
                const titleMatch = cleanedPart.match(regex);
                if (titleMatch) {
                    title = titleMatch[1].toUpperCase();
                    firstName = cleanedPart.substring(0, titleMatch.index).trim();
                    break;
                }
            }
            return { firstName, title };
        }


        // --- 마우스 이벤트 핸들러들 ---
        function handleMouseDown(event) { /* 변경 없음 */ const targetCell = event.target; if (targetCell.tagName === 'TD' && !targetCell.hasAttribute('colspan')) { isSelecting = true; startCell = targetCell; clearSelectionHighlights(); targetCell.classList.add('selected-cell'); document.body.classList.add('is-selecting'); copySelectionButton.disabled = true; selectionBounds = null; } }
        function handleMouseOver(event) { /* 변경 없음 */ if (!isSelecting || !startCell) return; const currentCell = event.target; if (currentCell.tagName === 'TD' && !currentCell.hasAttribute('colspan')) { highlightCells(startCell, currentCell); } }
        function handleMouseUp(event) { /* 변경 없음 */ if (isSelecting) { isSelecting = false; document.body.classList.remove('is-selecting'); const tableBodyRect = outputTableBody.getBoundingClientRect(); const mouseX = event.clientX; const mouseY = event.clientY; let endCell = startCell; if (mouseX >= tableBodyRect.left && mouseX <= tableBodyRect.right && mouseY >= tableBodyRect.top && mouseY <= tableBodyRect.bottom && event.target.tagName === 'TD') { endCell = event.target; } if (startCell && endCell && endCell.tagName === 'TD' && !endCell.hasAttribute('colspan')) { selectionBounds = calculateBounds(startCell, endCell); copySelectionButton.disabled = !selectionBounds; } else { selectionBounds = null; copySelectionButton.disabled = true; } } }
        function clearSelectionHighlights() { /* 변경 없음 */ const selectedCells = outputTableBody.querySelectorAll('.selected-cell'); selectedCells.forEach(cell => cell.classList.remove('selected-cell')); }
        function calculateBounds(startTd, endTd){ /* 변경 없음 */ const startRowIndex = startTd.parentNode.rowIndex; const startColIndex = startTd.cellIndex; const endRowIndex = endTd.parentNode.rowIndex; const endColIndex = endTd.cellIndex; return { minRow: Math.min(startRowIndex, endRowIndex), maxRow: Math.max(startRowIndex, endRowIndex), minCol: Math.min(startColIndex, endColIndex), maxCol: Math.max(startColIndex, endColIndex) }; }
        function highlightCells(startTd, endTd) { /* 변경 없음 */ clearSelectionHighlights(); const bounds = calculateBounds(startTd, endTd); const rows = outputTable.rows; const headerRowCount = outputTable.tHead ? outputTable.tHead.rows.length : 0; for (let i = bounds.minRow; i <= bounds.maxRow; i++) { if (i >= headerRowCount && rows[i] && rows[i].parentNode.tagName === 'TBODY') { const cells = rows[i].cells; for (let j = bounds.minCol; j <= bounds.maxCol; j++) { if (cells[j]) { cells[j].classList.add('selected-cell'); } } } } }

        // --- 복사 관련 함수 ---
        function getSelectedDataAsTsv(bounds) { /* 변경 없음 */ if (!bounds) return null; const selectedRowsTexts = []; const rows = outputTable.rows; const headerRowCount = outputTable.tHead ? outputTable.tHead.rows.length : 0; for (let i = bounds.minRow; i <= bounds.maxRow; i++) { if (i < headerRowCount || !rows[i] || rows[i].parentNode.tagName !== 'TBODY') continue; const currentRowTexts = []; const cells = rows[i].cells; for (let j = bounds.minCol; j <= bounds.maxCol; j++) { if (cells[j]) { currentRowTexts.push(cells[j].textContent); } else { currentRowTexts.push(""); } } selectedRowsTexts.push(currentRowTexts); } if (selectedRowsTexts.length === 0) return null; const tsvRows = selectedRowsTexts.map(rowArray => rowArray.join('\t')); return tsvRows.join('\n'); }
        function handleNativeCopy(event) { /* 변경 없음 */ if (selectionBounds) { const tsvData = getSelectedDataAsTsv(selectionBounds); if (tsvData && event.clipboardData) { event.preventDefault(); event.clipboardData.setData('text/plain', tsvData); copyFeedback.textContent = '✓ 선택 영역 복사 완료! (Ctrl+C)'; setTimeout(() => { copyFeedback.textContent = ''; }, 2000); } else if (tsvData) { console.warn("clipboardData API 사용 불가"); } } }
        function handleSelectionCopy() { /* 변경 없음 */ if (!selectionBounds) { alert("복사할 영역이 선택되지 않았습니다."); return; } const tsvData = getSelectedDataAsTsv(selectionBounds); if (!tsvData){ alert("선택된 영역에 복사할 데이터가 없습니다."); return; } if (navigator.clipboard && navigator.clipboard.writeText) { navigator.clipboard.writeText(tsvData).then(() => { copyFeedback.textContent = '✓ 선택 영역 복사 완료!'; setTimeout(() => { copyFeedback.textContent = ''; }, 2000); }).catch(err => { console.error('선택 영역 복사 실패:', err); alert('선택 영역 복사에 실패했습니다.'); copyFeedback.textContent = ''; }); } else { alert('클립보드 복사 기능이 지원되지 않는 브라우저입니다.'); copyFeedback.textContent = ''; } }
        function handleTableCopy() { /* 변경 없음 */ if (!currentResults || currentResults.length === 0) { alert('복사할 데이터가 없습니다.'); return; } const header = "번호\t영문 성\t영문 이름\t생년월일\t성별"; const rows = currentResults.map((rowArray, index) => { return (index + 1) + '\t' + rowArray.join('\t'); }); const tsvData = header + '\n' + rows.join('\n'); if (navigator.clipboard && navigator.clipboard.writeText) { navigator.clipboard.writeText(tsvData).then(() => { copyFeedback.textContent = '✓ 전체 복사 완료!'; setTimeout(() => { copyFeedback.textContent = ''; }, 2000); }).catch(err => { console.error('클립보드 복사 실패:', err); alert('클립보드 복사에 실패했습니다.'); copyFeedback.textContent = ''; }); } else { alert('클립보드 복사 기능이 지원되지 않는 브라우저입니다.'); copyFeedback.textContent = ''; } }

        // --- 헬퍼 함수 ---
        function getGender(title) { if (!title) return ''; const upperTitle = title.toUpperCase(); if (upperTitle === 'MS' || upperTitle === 'MISS') return '여'; else if (upperTitle === 'MR' || upperTitle === 'MSTR') return '남'; else return ''; }
        function convertDate(dateString) { // monthMap 인수 제거됨
            if (!dateString || dateString.length !== 7) return ''; const day = dateString.substring(0, 2); const monthAbbr = dateString.substring(2, 5).toUpperCase(); const yearSuffix = parseInt(dateString.substring(5, 7), 10); const month = MONTH_MAP[monthAbbr]; if (!month) return ''; const currentYear = new Date().getFullYear(); const century = Math.floor(currentYear / 100); const currentYearSuffix = currentYear % 100; const year = (yearSuffix > currentYearSuffix) ? (century - 1) * 100 + yearSuffix : century * 100 + yearSuffix; const tempDate = new Date(year, parseInt(month, 10) - 1, parseInt(day, 10)); if (tempDate.getFullYear() !== year || tempDate.getMonth() !== (parseInt(month, 10) - 1) || tempDate.getDate() !== parseInt(day, 10)) { return ''; } return `${year}${month}${day}`; }

    </script>

</body>
</html>
